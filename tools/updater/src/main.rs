use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::fs;
use std::io::Write;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectableGame {
    #[serde(default)]
    pub executables: Vec<Executable>,
    #[serde(default)]
    pub id: String,
    #[serde(default)]
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Executable {
    #[serde(default)]
    pub is_launcher: bool,
    #[serde(default)]
    pub name: String,
    #[serde(default)]
    pub os: Option<String>,
    #[serde(default)]
    pub arguments: Option<String>,
}

const API_URL: &str = "https://discord.com/api/v9/applications/detectable";
const RESOURCE_PATH: &str = "../../resources/detectable.json";
const GENERATED_PATH: &str = "../../src/process/generated_db.rs";

#[tokio::main]
async fn main() -> Result<()> {
    let cwd = std::env::current_dir()?;
    println!("CWD: {:?}", cwd);

    println!("Fetching detectable.json...");
    let response = reqwest::get(API_URL).await?;
    let new_games: Vec<DetectableGame> = response.json().await?;

    let resource_path = Path::new(RESOURCE_PATH);
    println!("Resource relative: {:?}", resource_path);
    if let Ok(abs) = fs::canonicalize(resource_path.parent().unwrap_or(Path::new("."))) {
        println!("Resource dir absolute: {:?}", abs);
    }

    let generated_path = Path::new(GENERATED_PATH);
    println!("Generated relative: {:?}", generated_path);
    if let Ok(abs) = fs::canonicalize(generated_path.parent().unwrap_or(Path::new("."))) {
        println!("Generated dir absolute: {:?}", abs);
    }

    // Create resources directory if it doesn't exist
    if let Some(parent) = resource_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let current_games: Vec<DetectableGame> = if resource_path.exists() {
        let content = fs::read_to_string(resource_path)?;
        serde_json::from_str(&content).unwrap_or_default()
    } else {
        Vec::new()
    };

    println!("Current games: {}", current_games.len());
    println!("New games: {}", new_games.len());

    let diff = new_games.len() as i32 - current_games.len() as i32;
    println!("Difference: {:+}", diff);

    // Compare names
    let old_names: HashSet<String> = current_games.iter().map(|g| g.name.clone()).collect();
    let new_names_list: Vec<String> = new_games
        .iter()
        .filter(|g| !old_names.contains(&g.name))
        .map(|g| g.name.clone())
        .collect();

    if !new_names_list.is_empty() {
        println!("New games found: {:?}", new_names_list);
    } else {
        println!("No new game titles found.");
    }

    // Save JSON
    let json_output = serde_json::to_string_pretty(&new_games)?;
    fs::write(resource_path, &json_output)?;
    println!("Saved to {:?}", resource_path);

    // Generate Rust code
    generate_rust_code(&new_games, Path::new(GENERATED_PATH))?;

    Ok(())
}

fn generate_rust_code(games: &[DetectableGame], path: &Path) -> Result<()> {
    let mut file = fs::File::create(path)?;

    writeln!(file, "// Auto-generated by tools/updater. DO NOT EDIT.")?;
    writeln!(file, "use crate::types::{{DetectableGame, Executable}};")?;
    writeln!(file, "use std::borrow::Cow::Borrowed;")?;
    writeln!(file, "")?;
    writeln!(file, "pub static DETECTABLE_GAMES: &[DetectableGame] = &[")?;

    for game in games {
        writeln!(file, "    DetectableGame {{")?;
        writeln!(file, "        id: Borrowed({:?}),", game.id)?;
        writeln!(file, "        name: Borrowed({:?}),", game.name)?;
        writeln!(file, "        executables: Borrowed(&[")?;
        for exe in &game.executables {
            writeln!(file, "            Executable {{")?;
            writeln!(file, "                name: Borrowed({:?}),", exe.name)?;
            writeln!(file, "                is_launcher: {},", exe.is_launcher)?;

            if let Some(os) = &exe.os {
                writeln!(file, "                os: Some(Borrowed({:?})),", os)?;
            } else {
                writeln!(file, "                os: None,")?;
            }

            if let Some(args) = &exe.arguments {
                writeln!(
                    file,
                    "                arguments: Some(Borrowed({:?})),",
                    args
                )?;
            } else {
                writeln!(file, "                arguments: None,")?;
            }

            writeln!(file, "            }},")?;
        }
        writeln!(file, "        ]),")?;
        writeln!(file, "    }},")?;
    }

    writeln!(file, "];")?;
    println!("Generated Rust code at {:?}", path);

    Ok(())
}
